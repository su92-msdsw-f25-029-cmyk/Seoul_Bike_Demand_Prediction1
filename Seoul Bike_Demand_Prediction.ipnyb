import pandas as pd
# Load CSV file
df = pd.read_csv('/content/SeoulBikeData.csv', encoding='latin-1')
# Display
df.head()
# Data Description
df.describe()
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'df' is your DataFrame and 'Rented Bike Count' is a column in it.
plt.figure(figsize=(8, 6))
sns.boxplot(x=df['Rented Bike Count'])
plt.title('Boxplot of Rented Bike Count')
plt.show()
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the CSV file into a pandas DataFrame.
df = pd.read_csv('/content/SeoulBikeData.csv', encoding='latin-1')

# **Exploratory data analysis.** (Charts: bar chart, histograms,
# boxplots, scatter plot etc.)

# Aggregate the data by Hour and sum the Rented Bike Count
hourly_rental_sum = df.groupby('Hour')['Rented Bike Count'].sum()

# Plot the aggregated data
hourly_rental_sum.plot(kind='bar', figsize=(10, 6), color='skyblue')
plt.title('Total Bike Rentals by Hour', fontsize=16)
plt.xlabel('Hour of the Day', fontsize=12)
plt.ylabel('Total Bike Rentals', fontsize=12)
plt.xticks(rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

# Histogram (example: Distribution of rented bike counts)
plt.figure(figsize=(8, 6))
plt.hist(df['Rented Bike Count'], bins=30)  # Adjust bins as needed
plt.title('Distribution of Rented Bike Counts')
plt.xlabel('Rented Bike Count')
plt.ylabel('Frequency')
plt.show()

# Boxplot (example: Distribution of temperature)
plt.figure(figsize=(8, 6))
sns.boxplot(x=df['Temperature(°C)'])
plt.title('Boxplot of Temperature')
plt.show()

# Scatter plot (example: Relationship between temperature and rented bike count)
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Temperature(°C)', y='Rented Bike Count', data=df)
plt.title('Temperature vs. Rented Bike Count')
plt.xlabel('Temperature (°C)')
plt.ylabel('Rented Bike Count')
plt.show()


# Additional plots (examples):

# Boxplot of 'Humidity(%)'
plt.figure(figsize=(8,6))
sns.boxplot(x=df['Humidity(%)'])
plt.title('Boxplot of Humidity')
plt.show()

# Scatter plot of 'Wind speed (m/s)' vs 'Visibility (10m)'
plt.figure(figsize=(10,6))
sns.scatterplot(x='Wind speed (m/s)', y='Visibility (10m)', data=df)
plt.title('Wind Speed vs Visibility')
plt.show()

# Aggregate the data by Seasons and sum the Rented Bike Count
seasonal_rental_sum = df.groupby('Seasons')['Rented Bike Count'].sum()

# Plot the aggregated data
seasonal_rental_sum.plot(kind='bar', figsize=(8, 6), color='coral')
plt.title('Total Bike Rentals per Season', fontsize=16)
plt.xlabel('Seasons', fontsize=12)
plt.ylabel('Total Bike Rentals', fontsize=12)
plt.xticks(rotation=0)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()
#!pip intall
!pip install ydata-profiling
import pandas as pd
from ydata_profiling import ProfileReport
print (df.info())
print(df.isnull().sum())
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from tensorflow import keras
from tensorflow.keras import layers

# Load the dataset
df = pd.read_csv('/content/SeoulBikeData.csv', encoding='latin-1')

# Preprocessing
# 1. Feature Engineering (Example: Combine date and time)
df['Date'] = pd.to_datetime(df['Date'], dayfirst=True)  # Specify dayfirst=True to match the date format
df['Hour'] = pd.to_numeric(df['Hour'])
df['Day'] = df['Date'].dt.dayofweek  # Create new feature for day of the week

# 2. Handle Categorical features
categorical_features = ['Seasons', 'Holiday', 'Functioning Day']
numerical_features = ['Hour', 'Temperature(°C)', 'Humidity(%)', 'Visibility (10m)',
                      'Dew point temperature(°C)', 'Solar Radiation (MJ/m2)',
                      'Rainfall(mm)', 'Snowfall (cm)', 'Day']

# Create a column transformer for preprocessing
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numerical_features),
        ('cat', OneHotEncoder(), categorical_features)
    ])

X = df.drop('Rented Bike Count', axis=1)
y = df['Rented Bike Count']
X_processed = preprocessor.fit_transform(X)

# Reshape data for RNN (Create sequences)
def create_sequences(features, target, sequence_length):
    X_seq, y_seq = [], []
    for i in range(len(features) - sequence_length):
        X_seq.append(features[i:i + sequence_length])
        y_seq.append(target[i + sequence_length])
    return np.array(X_seq), np.array(y_seq)

sequence_length = 24  # Example: Use the past 24 hours to predict the next hour
X_seq, y_seq = create_sequences(X_processed, y, sequence_length)

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_seq, y_seq, test_size=0.2, random_state=42)

# RNN Model
model = keras.Sequential([
    layers.SimpleRNN(256, activation='relu', return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])),
    layers.SimpleRNN(128, activation='relu'),
    layers.Dense(1)  # Output layer (regression)
])

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])

# Train the model
history = model.fit(X_train, y_train, epochs=100, batch_size=32, validation_split=0.2)

# Evaluate the model
loss, mae = model.evaluate(X_test, y_test)
print(f"Mean Absolute Error: {mae}")
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import matplotlib.pyplot as plt
import numpy as np

# Predict on the test data
y_pred = model.predict(X_test)
# Calculate evaluation metrics
mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error (MAE): {mae}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"R-squared (R²): {r2}")
# Visualize True vs Predicted Values
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred, alpha=0.5, color='blue')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], color='red', linestyle='--', linewidth=2)
plt.title('True vs Predicted Values')
plt.xlabel('True Values')
plt.ylabel('Predicted Values')
plt.grid(True)
plt.show()